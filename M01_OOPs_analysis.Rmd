---
title: "OOPs Analysis"
output: html_document
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r load_data, include = FALSE}
library(tidyverse)
library(magrittr)
library(knitr)
library(kableExtra)
library(hexbin)
library(gridExtra)
library(bookdown)



rm(list=ls())

# Load data
df <- readRDS("LSMScompilation_tidy_outliers")
df_nontidy <- readRDS("LSMScompilation_nontidy_outliers")
tab_recall <- readRDS("LSMScompilation_recall_nitems")
tab_survey_names <- read.csv("~/Dropbox/LSMS_Compilation/Analysis/Tables_Figures/table1_survey_description.csv")
hhinfo <- readRDS("LSMScompilation_hhinfo")

# Add hhinfo to DFs
df <- df %>% left_join(hhinfo, by="hhid_compilation")
df_nontidy <- df_nontidy %>% left_join(hhinfo, by="hhid_compilation")

```

# Search Strategy

The search started at the World Bank’s Microdata Library, where micro-surveys were collected from the Living Standards Measurement Surveys (LSMS) program. Data were retrieved from 80 surveys from the program which were publicly available.

```{r filter_surveys, include=FALSE}

# get list of surveys with both modules
surveys_bothmodules <- tab_recall %>% 
  select(survey) %>% 
  group_by(survey) %>% 
  mutate(count = n()) %>% 
  filter(count>1) %>% 
  select(survey) %>% 
  distinct()

# Keep only observations from selected surveys in df
df_bothm <- df %>% # df with surveys from both modules
  inner_join(surveys_bothmodules)

# keep only observations from selected surveys - nontidy
df_bothm_nontidy <- df_nontidy %>% 
  inner_join(surveys_bothmodules)
```

The surveys were analyzed to include only those with two OOPs measurements—one in the consumption module, and once more in the health module. Out of the 80 initial surveys, only `r length(surveys_bothmodules$survey)` measured OOPs in both modules, which will be the sample that will be used in this work.

# Surveys

The utilized sureys in the study are listed in Table 1. 

```{r descriptive_table, echo=FALSE, warning=FALSE, message=FALSE}

# Tab1 - grab surveys and names, plus characteristics
tab1_descriptive <- tab_survey_names %>% select(Survey, survey.name, LSMS) %>% 
  rename(`Survey Name` = survey.name,
         `LSMS Status` = LSMS,
         survey = Survey) %>% 
  inner_join(tab_recall) %>% # Guarantees to have only those that have both modules
  pivot_wider(names_from = module, values_from = c(recall,nitems)) %>% 
  group_by(survey) %>% 
  mutate(`Items Health Module` = first(nitems_Health),
            `Items Consumption Module` = last(nitems_Consumption),
            `Avg. Recall Health Module` = first(recall_Health),
            `Avg. Recall Consumption Module` = round(last(recall_Consumption),1 ) ) %>% 
  rename(Survey = survey) %>% 
  select(Survey, `Survey Name`, `LSMS Status`, `Items Health Module`,`Items Consumption Module`, `Avg. Recall Health Module`, `Avg. Recall Consumption Module` ) %>% 
  distinct()

# What are the surveys without hhweights?
surveys_nohhweight <- df_bothm_nontidy  %>% select(hhid_compilation, survey, hhweight) %>% 
  mutate(weight_missing = is.na(hhweight)) %>% 
  group_by(survey) %>% 
  summarise(per_missing = mean(weight_missing, na.rm = TRUE))


# Grab number of observations per survey
obs <- df_bothm_nontidy %>% 
  left_join(surveys_nohhweight) %>% 
  mutate(hhweight = ifelse(per_missing==1,1,hhweight)) %>% # Give weight 1 to surveys withoyut hhweights
  select(hhid_compilation, Health, Consumption, survey, nonhealth_consumption, hhweight) %>% 
  filter(Health>-1,Consumption>-1) %>%  # take NAs out 
  group_by(survey) %>% 
  summarise(Observations = n(),
            `Mean Non-Health Consumption` = round( weighted.mean(nonhealth_consumption,hhweight, na.rm = TRUE),1),
            `Mean OOPs Health Module` = round( weighted.mean(Health,hhweight, na.rm = TRUE),1),
            `Mean OOPs Consumption Module`  = round( weighted.mean(Consumption,hhweight, na.rm = TRUE),1)) %>% 
  left_join(surveys_nohhweight) %>%  # include again per_missing for formatting
  rename(Survey = survey)

# Put asterisk on numbers from surveys without hhweights
obs <- obs %>% 
  mutate(
    `Mean Non-Health Consumption` = ifelse(per_missing==1, str_c(as.character(`Mean Non-Health Consumption`),"*"),`Mean Non-Health Consumption`  ),
    `Mean OOPs Health Module` = ifelse(per_missing==1, str_c(as.character(`Mean OOPs Health Module`),"*"),`Mean OOPs Health Module`  ),
    `Mean OOPs Consumption Module` = ifelse(per_missing==1, str_c(as.character(`Mean OOPs Consumption Module`),"*"),`Mean OOPs Consumption Module`  )
  )

# Put observations in
tab1_descriptive <- tab1_descriptive %>% 
  left_join(obs) %>% 
  select(-per_missing)

# Table
kable(tab1_descriptive) %>% 
    kable_styling(bootstrap_options = c("striped", "hover")) %>% 
footnote(general = "Consumption averages are expressed in 2011 USD PPP. The surveys of Ghana_2006 through Ghana_2017 do not belong to the LSMS program, but they continue the work of previous LSMS surveys in Ghana.
         * sampling weights were not available for calculation")
  



```





# Household OOPs

With two different OOP estimates for each household for `r length(surveys_bothmodules$survey)` surveys, there is an opportunity to explore how much the reported OOPs differ by the module in the same household. Figure 1 exhibits a heatmap for each survey. OOPs in the health module are on the y-axis, while OOPs in the consumption module are on the x-axis. The color of the hexagons represents the concentration of observations around the area, with more intense tones representing a higher concentration.


It is interesting to see that some surveys do a very good job at eliciting similar OOPs between modules, such as the surveys from Uganda, and Bulgaria. On the other hand, all other surveys have a clear pattern of higher OOPs in the health module, with the exception of Ghana 2017.

```{r scatter_health_consumption, echo=FALSE, warning=FALSE, message=FALSE}

scatter_xy <- function(survey_name){

# Filter survey and take outliers out
data <- df_bothm_nontidy %>% 
  filter(survey==survey_name) %>%
  select(hhid_compilation,Consumption,Health) %>% 
  na.omit() %>% 
  mutate(z_health = Health / sd(Health, na.rm = TRUE),
         z_consumption = Consumption / sd(Consumption, na.rm = TRUE)) %>% 
  filter(z_health<2, z_consumption<2) %>%  # take out all those with z>2 for viz purposes
  rename(`Health Module` = Health,
         `Consumption Module` = Consumption)

# Limit for both axis for viz  
max_scale <- data %$% 
    max( max(`Health Module`, na.rm = TRUE), max(`Consumption Module`)     , na.rm = TRUE)

# Number of bins (optional to use)
nbins <- data %>% 
  nrow() / 100
  
# one special for Ghana 2013
  if (survey_name=="Ghana_2013"){
    graph <- data %>% 
      ggplot(aes(`Consumption Module`,`Health Module`)) +
      #geom_point(alpha = 1/10) +
      geom_hex(bins = 68) +
      scale_fill_gradient(low = "yellow", high = "red", limits = c(5, 200) , guide = FALSE) + #option to show the
      geom_abline(intercept = 0, slope = 1, alpha=20, linetype = "dashed", color="black") +
      scale_y_continuous(limits = c(0,max_scale)) +
      scale_x_continuous(limits = c(0,max_scale)) +
      ggtitle(survey_name) +
      theme(axis.text = element_text(size = 5), 
            axis.title = element_text(size = 5),
            plot.title = element_text(size = 11, face = "bold", hjust=0.5))
    
    graph

# All the rest  
  } else{
  
    graph <- data %>% 
    ggplot(aes(`Consumption Module`,`Health Module`)) +
    #geom_point(alpha = 1/10) +
    geom_hex() + #bins= nbins
    scale_fill_gradient(low = "yellow", high = "red", limits = c(5, 200) , guide = FALSE) + #option to show the
    geom_abline(intercept = 0, slope = 1, alpha=20, linetype = "dashed", color="black") +
    scale_y_continuous(limits = c(0,max_scale)) +
    scale_x_continuous(limits = c(0,max_scale)) +
    ggtitle(survey_name) +
    theme(axis.text = element_text(size = 5), 
            axis.title = element_text(size = 5),
            plot.title = element_text(size = 11, face = "bold", hjust=0.5))
  
  graph
  }

}

# List of surveys
bothm_surveylist <- surveys_bothmodules$survey %>% 
  as.character()

# get all the graphs
hex_graphs <- bothm_surveylist %>%  map(scatter_xy)


# Put all graphs in one page
grid.arrange(hex_graphs[[1]],hex_graphs[[2]],hex_graphs[[3]],hex_graphs[[4]],
             hex_graphs[[5]],hex_graphs[[6]],hex_graphs[[7]],hex_graphs[[8]],
             hex_graphs[[9]],hex_graphs[[10]],hex_graphs[[11]],hex_graphs[[12]],
             hex_graphs[[13]],hex_graphs[[14]],hex_graphs[[15]],hex_graphs[[16]], hex_graphs[[17]])


```


Table 1 exhibits the instrument characteristics of each survey, sorting them by their regression coefficient. The coefficient was obtained by regressing the OOPs in the health module as the dependent variable, and the OOPs in the consumption module as the independent variable. A coefficient of one represents that the two modules are measuring the same underlying variable, but with some statistical noise involved. Coefficients straying away from one, on the other hand, relate to a mismatch in measuring between modules.

All surveys that have coefficients close to 1 have equal average recall periods in their consumption and health modules—pointing to the importance of using the same recall periods in order to have comparable OOPs between modules.


```{r simple_model_OOPs, echo=FALSE, warning=FALSE, message=FALSE}

# Create simple regression
survey_model <- function(survey_name){
  df_aux <- df_bothm_nontidy %>% filter(survey==survey_name)
  model <- lm(Health ~ Consumption , data = df_aux)
  coef(model)[[2]]
}


coefs <- bothm_surveylist %>% map(survey_model) %>% unlist()

tab_reg <- tibble(coef = coefs, survey = bothm_surveylist) %>%
  inner_join(tab_recall) %>% pivot_wider(names_from = module, values_from = c(recall,nitems)) %>% 
  group_by(survey) %>% 
  transmute(
            `Regression Coefficient` = round(coef,2),
            `Items Health Module` = first(nitems_Health),
            `Items Consumption Module` = last(nitems_Consumption),
            `Avg. Recall Health Module` = first(recall_Health),
            `Avg. Recall Consumption Module` = round(last(recall_Consumption),1 ) ) %>% 
  rename(Survey = survey) %>% 
  distinct() %>% 
  arrange(`Regression Coefficient`)


kable(tab_reg) %>% 
  kable_styling(bootstrap_options = c("striped", "hover")) %>% 
   footnote(general = "The number of items correspond to the number of instruments utilized in the survey to arrive at the OOPs estimate in each module. The average recall period is in weeks, and represents how far back in time households were asked to recall their expenditures")
  
```



# Average OOPs

```{r get_means , include=FALSE, warning=FALSE, message=FALSE}

# Create DF with "fake" weights for surveys without them
df_bothm_nontidy_weightcorrected <- df_bothm_nontidy %>% 
  left_join(surveys_nohhweight) %>% 
  mutate(hhweight = ifelse(per_missing==1,1,hhweight)) %>%  # Give weight 1 to surveys withoyut hhweights 
  filter(Health>-1,Consumption>-1)  # take NAs out 

df_bothm_tidy_weightcorrected <- df_bothm %>% 
  left_join(surveys_nohhweight) %>% 
  mutate(hhweight = ifelse(per_missing==1,1,hhweight)) %>%  # Give weight 1 to surveys withoyut hhweights 
  filter(oops>-1)  # take NAs out 

# Grab means by survey and module - and order surveys
tab_mean_oops <- df_bothm_nontidy_weightcorrected %>% 
  group_by(survey) %>% 
  summarise(mean_Consumption = weighted.mean(Consumption,hhweight, na.rm = TRUE),
            mean_Health = weighted.mean(Health,na.rm = TRUE),
            obs = n()) %>% 
  mutate(Health_over_Consumption = mean_Health / mean_Consumption,
         Consumption_over_Health = mean_Consumption / mean_Health,
          order = seq_along(survey),
          survey2 = fct_reorder(survey, desc(order) ) )


# get number where health module is higher
nhealth_higher <- tab_mean_oops %>% 
  filter(Health_over_Consumption>1) %>% 
  nrow()

```


In our sample of surveys, the mean OOPs in the health module were higher than in the consumption module for most surveys. In fact, `r nhealth_higher` out of `r length(surveys_bothmodules$survey)` have higher mean OOPs in the health module, as can be seen in Figure 1. These are the surveys that have a share less than one, indicating that the mean OOPs in their consumption module are lower than the mean OOPs from their health module.


```{r mean_graph, echo=FALSE}
# Graph Average Means by survey
tab_mean_oops %>% 
  ggplot(aes( survey2 ,Health_over_Consumption)) +
  geom_point(color="blue") +
  coord_flip() +
  ggtitle("Mean OOPs from the health module over the consumption module") +
  xlab("") +
  ylab("Ratio") +
  geom_hline(yintercept=1, alpha=3, linetype = "dashed") +
  scale_y_continuous(breaks = seq(0,7,1), limits = c(0,7))
```

```{r prep_zero_oops, include=FALSE}

# Percentage by survey with zero oops
per_zero <- df_bothm_tidy_weightcorrected %>% 
  group_by(survey,module) %>% 
  mutate(zero_oops = oops==0) %>% 
  summarise(mean_zero = mean(zero_oops, na.rm = TRUE)) %>% 
  ungroup() %>% 
  group_by(module) %>% 
  summarise(mean_zero2 = mean(mean_zero, na.rm = TRUE))

# Grab means for oops>0
tab_mean_oops_zero <- df_bothm_tidy_weightcorrected %>% 
  filter(oops>0) %>% 
  group_by(survey,module) %>% 
  summarise(mean_oops = mean(oops, na.rm = TRUE),
            obs = n())

# Grab OOPs of health module over OOPs of consumption module
tab_health_over_consumption_zero <- tab_mean_oops_zero %>% 
  group_by(survey) %>% 
  mutate(healthm_healthc = last(mean_oops) / first(mean_oops), # consumption over health
         healthc_healthm = first(mean_oops) / last(mean_oops) ) %>%  # health over consumption
  ungroup() %>% 
  select(survey, healthc_healthm, healthm_healthc) %>% 
  distinct() %>% 
  mutate( order = seq_along(survey),
          survey2 = fct_reorder(survey, desc(order) ))


# get number where health module is higher
nhealth_higher_zero <- tab_health_over_consumption_zero %>% 
  filter(healthc_healthm<1) %>% 
  nrow()
```


```{r mean_oops_zeroplus, echo=FALSE}
# Graph Average Means by survey - positive oops
tab_health_over_consumption_zero %>% 
  ggplot(aes( survey2 ,healthm_healthc)) +
  geom_point(color="blue") +
  coord_flip() +
  ggtitle("Mean OOPs from the health module over the consumption module") +
  labs(subtitle = "For households reporting positive OOPs") +
  xlab("") +
  ylab("Share") +
  geom_hline(yintercept=1, alpha=3, linetype = "dashed") +
  scale_y_continuous(breaks = seq(0,15,1), limits = c(0,15))
```

On average `r round(per_zero$mean_zero2[[1]]*100,1)`% and `r round(per_zero$mean_zero2[[2]]*100,1)`% of the households report zero OOPs in the consumption and health module respectively.

Figure 2 exhibits that `r nhealth_higher_zero` out of `r length(surveys_bothmodules$survey)` have higher mean OOPs in the health module than in the consumption module after excluding observations reporting zero OOPs. However, mean OOPs from the health module are still higher, and the patterns remain the same compared to Figure 1.



```{r repetition_zeros, include=FALSE}

df_zero <- df_bothm_nontidy %>%
    mutate(
    c0_h0 = Consumption==0 & Health==0,
    c1_h0 = Consumption>0 & Health==0,
    c0_h1 = Consumption==0 & Health>0,
    c1_h1 = Consumption>0 & Health>0 )

df_zero2 <- df_zero %>% 
  select(hhid_compilation,survey, c0_h0, c1_h0, c0_h1, c1_h1) %>% 
  distinct()

# Table with concordance categories by survey
tab_zero_reps <- df_zero2 %>% 
  group_by(survey) %>% 
  summarise(both_zero = mean(c0_h0, na.rm = TRUE),
            posc_zeroh = mean(c1_h0, na.rm = TRUE),
            zeroc_posh = mean(c0_h1, na.rm = TRUE),
            posc_poch = mean(c1_h1, na.rm = TRUE))

# Calculate Average concordance across surveys
per_concordance <- tab_zero_reps %>% 
  summarise(both_zero2 = mean(both_zero, na.rm = TRUE),
            both_pos2 = mean(posc_poch, na.rm = TRUE))


```

# Zero OOPs

Households reporting zero OOPs is a common characteristic of health care data. Many households do not spend on health care because they had no health shocks, or they could not afford treatment. On average `r round(per_zero$mean_zero2[[1]]*100,1)`% and `r round(per_zero$mean_zero2[[2]]*100,1)`% of the households report zero OOPs in the consumption and health module respectively.

As the percentage of zero OOPs differs between modules in all surveys, it will be interesting to check how concordant the answers between modules are. Across all surveys, `r round(per_concordance$both_zero2[[1]]*100,1)`% of households report zero OOPs in both modules, and `r round(per_concordance$both_pos2[[1]]*100,1)`% report positive OOPs in both. In total `r (  round(   (per_concordance$both_zero2[[1]] + per_concordance$both_pos2[[1]])*100    ,1 )    )`% of households report concordant OOPs between modules (both positive, or both negative), leaving `r 100- (  round(   (per_concordance$both_zero2[[1]] + per_concordance$both_pos2[[1]])*100    ,1 )    )`% of households that differ on their answers between modules, which is problematic from a measuring perspective.

Table 1 exhibits the concordance of household's answers between the health module and consumption module by survey. The percentages vary widely by surveys, Ghana_1991 and Ghana_2005 both have zero households reporting zero OOPs in both modules (as both of them had OOPs instruments in consumption modules administered frequently by visits throughout the year). On the other hand, the surveys from Uganda show 30%+ of households reporting zero OOPs in both modules.


Ghana_1991 has the worst non-correspondant rates, where 57.9% of households reported positive OOPs in the health or consumption module, and then reported zero on the other one. The latter discrepancy is solely driven by the zero OOPs responses in the health module, which are episodic, so in order for individuals to report OOPs they needed to report being recently ill. On the other hand, the non-concordance rate of Nigeria_2015 is entirely explained by its consumption module. The OOPs instrument happened to be a single question asking households for their total OOPs.



```{r table_zero_concordance, echo=FALSE}

# Put it in percentage
percentage <- function(x){
  round(x*100,1)
  }

tab_zero_reps_per <- tab_zero_reps %>% 
  mutate_at(vars(matches("h")) , percentage) %>% 
  mutate(`Concordance Rate` = both_zero + posc_poch,
         `Non-Concordance Rate` = 100- (both_zero + posc_poch) ) %>% 
  rename(`Both Zero` = both_zero,
         `C>0, H=0` = posc_zeroh,
         `C=0, H>0` = zeroc_posh,
         `Both Positive` = posc_poch,
         Survey = survey)

  kable(tab_zero_reps_per ) %>% 
  kable_styling(bootstrap_options = c("striped", "hover")) %>% 
    footnote(general = "The columns represent the percentage of households in each category depending on their reported OOPs in the consumption and health module. The first column is the percentage of households in the survey that reported zero OOPS in both the health module and consumption module. The second column is the percentage of households reporting strictly positive OOPs in the consumption module, and zero OOPs in the health module. ")
```
# Mean OOPs by Module and socio-economic status

So far, the mean OOPs from the health module have been higher than those from the consumption module. A possibility is that the socio-economic status of households drives this. Rich or poor households might report more or less OOPs in a specific module. To asses this possibility, quintiles of non-health consumption will be used as a proxy for socio-economic status. Excluding OOPs to asses, socio-economic status is essential as total consumption is not a relevant social marker for households experiencing a health shock, and they had to go through high health care expenditures because of it.

Figure 3 exhibits the mean OOPs of the consumption module over the health module, by survey and consumption quintile. We observe no clear pattern between socio-economic status and the differences in the reported OOPs between both modules.


```{r mean_consumption_quintile, echo=FALSE}

# Grab means by survey and module, and consumption quintile
tab_mean_cq <- df_bothm_tidy_weightcorrected %>% 
  group_by(survey,module,consumption_quintile) %>% 
  summarise(mean_oops = weighted.mean(oops, hhweight, na.rm = TRUE),
            obs = n())

# Grab OOPs of health module over OOPs of consumption module
tab_hc_cq <- tab_mean_cq %>% 
  group_by(survey,consumption_quintile) %>% 
  mutate(Health_over_Consumption = last(mean_oops) / first(mean_oops) ) %>% 
  ungroup() %>% 
  select(survey, consumption_quintile, Health_over_Consumption) %>% 
  distinct() %>% 
  mutate( order = seq_along(survey),
          survey2 = fct_reorder(survey, desc(order) )) %>% # Create order for surveys
  filter(consumption_quintile> -1) # eliminate those with NA


# Graph mean
tab_hc_cq %>% 
  ggplot(aes(x=survey2,y=Health_over_Consumption, 
             group = reorder(consumption_quintile, -consumption_quintile), 
             fill = consumption_quintile) ) +
  geom_bar(position='dodge', stat='identity') +
  coord_flip() +
  ggtitle("Mean OOPs from the health module over the consumption module") +
  labs(subtitle = "By consumption quintile") +
  xlab("") +
  ylab("Ratio") +
  scale_y_continuous(breaks = seq(0,12,1), limits = c(0,12)) +
  geom_hline(yintercept=1, alpha=3, linetype = "dashed")


```

# Catastrophic health expenditures (CHEs)

Popular datasets like the World's Bank HEFPI, and the World Development Indicators include estimations for the percentage of households incurring into a level of OOPs that is too burdensome to bear. The most popular indicators are Catastrophic health expenditures, which consist on a ratio between the OOPs of a household and its total available resources. What is troubling, is that these popular datasets publish their estimates without stating if the OOPs were coming from the health or consumption module, and without awareness of what are the possible effects of these.

We will use our sample of surveys with OOPs in a consumption and health module, and add these two estimates of OOPs to the non-health consumption of each household to come up with two different estimates of total consumption. Then, we will be able to calculate the most popular indicator of the CHE kind, 10% of total consumption, which is simply an binary variable of whether a household's OOPs exceed 10% of their total consumption.

Previously, it was evident that mean OOPs were higher for the health module in most surveys. We expect that this should make CHE rates higher using OOPs from the health module, but two factors will determine the magnitude of this difference. The first being if the difference in OOPs between modules is relevant for households with high expenditures. The second being, how significant are OOPs as a share in the total consumption of households.

In Figure 6, the CHE10% estimates using OOPs from the health module, and consumption module are exhibited. Note that there are barely any differences in the Uganda surveys, which happened to have very similar mean OOPs. Nonetheless, for other surveys, the difference can be spectacular, in Nigeria_2015 CHEs jumped from 11% to 53% by using the health module. In Nigeria_2012 from 0.3% to 6%. Overall, the pattern is clear in that OOPs using the health module are higher, with two exceptions Ghana_2017 and Ghana_1991.



```{r che_graph, echo=FALSE, message=FALSE, warning=FALSE}

df_che <- df_bothm_tidy_weightcorrected %>% 
  left_join(hhinfo %>% select(hhid_compilation,hhsize)) %>% 
  filter(!is.na(hhsize)) %>% 
  mutate(total_consumption =  nonhealth_consumption + oops,
         che10 = (oops/total_consumption)>.1,
         che25 = (oops/total_consumption)>.25,
         pop_weight = hhweight*hhsize)

tab_che <- df_che %>% 
  group_by(survey,module) %>% 
  summarise(mean_che10 = weighted.mean(che10,pop_weight, na.rm = TRUE),
            mean_che25 = weighted.mean(che25,pop_weight, na.rm = TRUE))


tab_che %>% 
  ggplot(aes(survey,mean_che10, color = module)) +
  geom_point() +
  coord_flip() +
  scale_y_continuous(breaks = seq(0,.6,.1), limits = c(0,.6))

```














